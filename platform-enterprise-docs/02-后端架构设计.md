# Platform Enterprise - 后端架构设计

> 基于 Spring Boot 4.0 的企业级多模块后端架构

## 1. 整体架构

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Presentation Layer                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐    │
│  │ REST API    │ │ WebSocket   │ │ GraphQL     │ │ gRPC (optional) │    │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────────┘    │
├─────────────────────────────────────────────────────────────────────────┤
│                           Application Layer                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐    │
│  │ Service     │ │ Facade      │ │ Assembler   │ │ Event Handler   │    │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────────┘    │
├─────────────────────────────────────────────────────────────────────────┤
│                             Domain Layer                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐    │
│  │ Entity      │ │ Value Object│ │ Domain Svc  │ │ Repository Port │    │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────────┘    │
├─────────────────────────────────────────────────────────────────────────┤
│                         Infrastructure Layer                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐    │
│  │ Repository  │ │ Gateway     │ │ Messaging   │ │ External API    │    │
│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────────┘    │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 模块依赖关系

```
platform-parent (POM)
│
├── platform-common           # 通用工具
│   ├── common-core          # 核心工具类
│   ├── common-web           # Web 通用组件
│   ├── common-security      # 安全通用组件
│   └── common-data          # 数据访问通用组件
│
├── platform-api              # API 定义
│   ├── api-user             # 用户服务 API
│   ├── api-auth             # 认证服务 API
│   └── api-business         # 业务服务 API
│
├── platform-gateway          # API 网关
│
├── platform-auth             # 认证服务
│
├── platform-user             # 用户服务
│
├── platform-business         # 业务服务
│
├── platform-file             # 文件服务
│
├── platform-message          # 消息服务
│
├── platform-job              # 定时任务服务
│
└── platform-monitor          # 监控服务
```

## 2. 模块详细设计

### 2.1 platform-common 通用模块

#### 2.1.1 common-core

```java
// 统一响应结构
public record ApiResponse<T>(
    int code,
    String message,
    T data,
    long timestamp
) {
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(200, "success", data, System.currentTimeMillis());
    }

    public static <T> ApiResponse<T> error(int code, String message) {
        return new ApiResponse<>(code, message, null, System.currentTimeMillis());
    }
}

// 统一异常定义
public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
}

// 错误码枚举
public enum ErrorCode {
    SUCCESS(200, "操作成功"),
    BAD_REQUEST(400, "请求参数错误"),
    UNAUTHORIZED(401, "未授权"),
    FORBIDDEN(403, "禁止访问"),
    NOT_FOUND(404, "资源不存在"),
    INTERNAL_ERROR(500, "服务器内部错误"),

    // 业务错误码 (1000+)
    USER_NOT_FOUND(1001, "用户不存在"),
    USER_DISABLED(1002, "用户已禁用"),
    PASSWORD_ERROR(1003, "密码错误");

    private final int code;
    private final String message;
}

// 分页请求
public record PageRequest(
    @Min(1) int page,
    @Min(1) @Max(100) int size,
    String sortBy,
    String sortDir
) {
    public static PageRequest of(int page, int size) {
        return new PageRequest(page, size, null, null);
    }

    public Pageable toPageable() {
        Sort sort = sortBy != null
            ? Sort.by(Sort.Direction.fromString(sortDir), sortBy)
            : Sort.unsorted();
        return org.springframework.data.domain.PageRequest.of(page - 1, size, sort);
    }
}

// 分页响应
public record PageResponse<T>(
    List<T> items,
    long total,
    int page,
    int size,
    int totalPages
) {
    public static <T> PageResponse<T> of(Page<T> page) {
        return new PageResponse<>(
            page.getContent(),
            page.getTotalElements(),
            page.getNumber() + 1,
            page.getSize(),
            page.getTotalPages()
        );
    }
}
```

#### 2.1.2 common-web

```java
// 全局异常处理器
@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(BusinessException.class)
    public ApiResponse<Void> handleBusinessException(BusinessException e) {
        log.warn("Business exception: {}", e.getMessage());
        return ApiResponse.error(e.getErrorCode().getCode(), e.getMessage());
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ApiResponse<Void> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.joining(", "));
        return ApiResponse.error(400, message);
    }

    @ExceptionHandler(Exception.class)
    public ApiResponse<Void> handleException(Exception e) {
        log.error("Unexpected exception", e);
        return ApiResponse.error(500, "服务器内部错误");
    }
}

// 请求日志切面
@Aspect
@Component
public class RequestLogAspect {

    private static final Logger log = LoggerFactory.getLogger(RequestLogAspect.class);

    @Around("@within(org.springframework.web.bind.annotation.RestController)")
    public Object logRequest(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        String method = joinPoint.getSignature().toShortString();

        try {
            Object result = joinPoint.proceed();
            long elapsed = System.currentTimeMillis() - start;
            log.info("Request {} completed in {}ms", method, elapsed);
            return result;
        } catch (Exception e) {
            long elapsed = System.currentTimeMillis() - start;
            log.error("Request {} failed in {}ms: {}", method, elapsed, e.getMessage());
            throw e;
        }
    }
}
```

### 2.2 platform-gateway 网关服务

```java
// 网关配置
@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            // 认证服务
            .route("auth-service", r -> r
                .path("/api/auth/**")
                .filters(f -> f
                    .stripPrefix(1)
                    .addRequestHeader("X-Gateway-Time", String.valueOf(System.currentTimeMillis())))
                .uri("lb://platform-auth"))

            // 用户服务
            .route("user-service", r -> r
                .path("/api/users/**")
                .filters(f -> f
                    .stripPrefix(1)
                    .circuitBreaker(c -> c
                        .setName("userServiceCB")
                        .setFallbackUri("forward:/fallback/users")))
                .uri("lb://platform-user"))

            // 业务服务
            .route("business-service", r -> r
                .path("/api/business/**")
                .filters(f -> f.stripPrefix(1))
                .uri("lb://platform-business"))

            .build();
    }
}

// 全局过滤器 - 认证
@Component
public class AuthenticationFilter implements GlobalFilter, Ordered {

    private final JwtTokenProvider tokenProvider;
    private final List<String> whiteList = List.of(
        "/api/auth/login",
        "/api/auth/register",
        "/api/auth/refresh"
    );

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().value();

        // 白名单放行
        if (whiteList.stream().anyMatch(path::startsWith)) {
            return chain.filter(exchange);
        }

        // 验证令牌
        String token = extractToken(exchange.getRequest());
        if (token == null || !tokenProvider.validateToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }

        // 传递用户信息到下游服务
        String userId = tokenProvider.getUserId(token);
        ServerHttpRequest request = exchange.getRequest().mutate()
            .header("X-User-Id", userId)
            .build();

        return chain.filter(exchange.mutate().request(request).build());
    }

    @Override
    public int getOrder() {
        return -100;
    }

    private String extractToken(ServerHttpRequest request) {
        String bearerToken = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

// 限流配置
@Configuration
public class RateLimiterConfig {

    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> {
            String userId = exchange.getRequest().getHeaders().getFirst("X-User-Id");
            return Mono.just(userId != null ? userId : exchange.getRequest().getRemoteAddress().getHostString());
        };
    }

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        // 每秒 100 请求，突发 200
        return new RedisRateLimiter(100, 200);
    }
}
```

### 2.3 platform-auth 认证服务

```java
// 认证控制器
@RestController
@RequestMapping("/auth")
@Tag(name = "认证管理", description = "用户登录、注册、令牌刷新")
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    @Operation(summary = "用户登录")
    public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        return ApiResponse.success(authService.login(request));
    }

    @PostMapping("/logout")
    @Operation(summary = "用户登出")
    public ApiResponse<Void> logout(@RequestHeader("Authorization") String token) {
        authService.logout(token);
        return ApiResponse.success(null);
    }

    @PostMapping("/refresh")
    @Operation(summary = "刷新令牌")
    public ApiResponse<TokenResponse> refresh(@RequestBody RefreshRequest request) {
        return ApiResponse.success(authService.refresh(request.refreshToken()));
    }
}

// 登录请求
public record LoginRequest(
    @NotBlank(message = "用户名不能为空")
    @Size(min = 4, max = 50, message = "用户名长度 4-50 字符")
    String username,

    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 100, message = "密码长度 6-100 字符")
    String password,

    String captchaCode,
    String captchaKey
) {}

// 登录响应
public record LoginResponse(
    String accessToken,
    String refreshToken,
    long expiresIn,
    UserInfo userInfo
) {}

// 认证服务
@Service
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider tokenProvider;
    private final RedisTemplate<String, String> redisTemplate;

    public LoginResponse login(LoginRequest request) {
        // 查找用户
        User user = userRepository.findByUsername(request.username())
            .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));

        // 验证密码
        if (!passwordEncoder.matches(request.password(), user.getPassword())) {
            throw new BusinessException(ErrorCode.PASSWORD_ERROR);
        }

        // 检查状态
        if (user.getStatus() != UserStatus.ACTIVE) {
            throw new BusinessException(ErrorCode.USER_DISABLED);
        }

        // 生成令牌
        String accessToken = tokenProvider.generateAccessToken(user);
        String refreshToken = tokenProvider.generateRefreshToken(user);

        // 存储令牌到 Redis
        String tokenKey = "platform:auth:token:" + user.getId();
        redisTemplate.opsForValue().set(tokenKey, accessToken, Duration.ofHours(2));

        return new LoginResponse(
            accessToken,
            refreshToken,
            7200,
            UserInfo.from(user)
        );
    }

    public void logout(String bearerToken) {
        String token = bearerToken.replace("Bearer ", "");
        String userId = tokenProvider.getUserId(token);

        // 删除 Redis 中的令牌
        String tokenKey = "platform:auth:token:" + userId;
        redisTemplate.delete(tokenKey);

        // 将令牌加入黑名单
        String blacklistKey = "platform:auth:blacklist:" + token;
        redisTemplate.opsForValue().set(blacklistKey, "1", Duration.ofHours(2));
    }
}

// JWT 令牌提供者
@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token-expiration:7200}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token-expiration:604800}")
    private long refreshTokenExpiration;

    private SecretKey getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateAccessToken(User user) {
        return Jwts.builder()
            .subject(user.getId().toString())
            .claim("username", user.getUsername())
            .claim("roles", user.getRoles())
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + accessTokenExpiration * 1000))
            .signWith(getSigningKey())
            .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public String getUserId(String token) {
        return Jwts.parser()
            .verifyWith(getSigningKey())
            .build()
            .parseSignedClaims(token)
            .getPayload()
            .getSubject();
    }
}
```

### 2.4 platform-user 用户服务

```java
// 用户实体
@Entity
@Table(name = "t_user")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, length = 100)
    private String password;

    @Column(length = 100)
    private String email;

    @Column(length = 20)
    private String phone;

    @Column(length = 100)
    private String nickname;

    @Column(length = 255)
    private String avatar;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private UserStatus status = UserStatus.ACTIVE;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "t_user_role", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role")
    private Set<String> roles = new HashSet<>();

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

// 用户状态枚举
public enum UserStatus {
    ACTIVE,      // 正常
    INACTIVE,    // 未激活
    LOCKED,      // 锁定
    DISABLED     // 禁用
}

// 用户 Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);

    boolean existsByUsername(String username);

    boolean existsByEmail(String email);

    @Query("SELECT u FROM User u WHERE u.status = :status")
    Page<User> findByStatus(@Param("status") UserStatus status, Pageable pageable);

    @Query("SELECT u FROM User u WHERE " +
           "(:keyword IS NULL OR u.username LIKE %:keyword% OR u.nickname LIKE %:keyword%)")
    Page<User> search(@Param("keyword") String keyword, Pageable pageable);
}

// 用户服务
@Service
@Transactional
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;

    public UserDTO createUser(CreateUserRequest request) {
        // 检查用户名是否存在
        if (userRepository.existsByUsername(request.username())) {
            throw new BusinessException(ErrorCode.USER_EXISTS);
        }

        // 创建用户
        User user = new User();
        user.setUsername(request.username());
        user.setPassword(passwordEncoder.encode(request.password()));
        user.setEmail(request.email());
        user.setNickname(request.nickname());
        user.setRoles(Set.of("ROLE_USER"));

        user = userRepository.save(user);
        return userMapper.toDTO(user);
    }

    @Transactional(readOnly = true)
    public UserDTO getUser(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));
        return userMapper.toDTO(user);
    }

    @Transactional(readOnly = true)
    public PageResponse<UserDTO> listUsers(UserQueryRequest request) {
        Pageable pageable = request.toPageable();
        Page<User> page = userRepository.search(request.keyword(), pageable);
        return PageResponse.of(page.map(userMapper::toDTO));
    }

    public UserDTO updateUser(Long id, UpdateUserRequest request) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));

        if (request.nickname() != null) {
            user.setNickname(request.nickname());
        }
        if (request.email() != null) {
            user.setEmail(request.email());
        }
        if (request.avatar() != null) {
            user.setAvatar(request.avatar());
        }

        user = userRepository.save(user);
        return userMapper.toDTO(user);
    }

    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new BusinessException(ErrorCode.USER_NOT_FOUND);
        }
        userRepository.deleteById(id);
    }
}

// MapStruct 映射器
@Mapper(componentModel = "spring")
public interface UserMapper {

    UserDTO toDTO(User user);

    List<UserDTO> toDTOList(List<User> users);
}
```

## 3. 虚拟线程配置

### 3.1 启用虚拟线程

```yaml
# application.yml
spring:
  threads:
    virtual:
      enabled: true

  # Tomcat 配置
  server:
    tomcat:
      threads:
        max: 200
        min-spare: 10
```

### 3.2 异步任务配置

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean
    public TaskExecutor taskExecutor() {
        // 使用虚拟线程执行器
        return new TaskExecutorAdapter(Executors.newVirtualThreadPerTaskExecutor());
    }
}

// 使用异步任务
@Service
public class NotificationService {

    @Async
    public CompletableFuture<Void> sendEmail(String to, String subject, String content) {
        // 在虚拟线程中执行
        // 实际发送邮件逻辑
        return CompletableFuture.completedFuture(null);
    }
}
```

## 4. 声明式 HTTP 客户端

### 4.1 定义服务客户端

```java
// 用户服务客户端
@HttpExchange("/users")
public interface UserClient {

    @GetExchange("/{id}")
    UserDTO getById(@PathVariable Long id);

    @GetExchange
    PageResponse<UserDTO> list(@RequestParam int page, @RequestParam int size);

    @PostExchange
    UserDTO create(@RequestBody CreateUserRequest request);

    @PutExchange("/{id}")
    UserDTO update(@PathVariable Long id, @RequestBody UpdateUserRequest request);

    @DeleteExchange("/{id}")
    void delete(@PathVariable Long id);
}

// 配置客户端
@Configuration
public class HttpClientConfig {

    @Bean
    public UserClient userClient(RestClient.Builder builder) {
        RestClient restClient = builder
            .baseUrl("http://platform-user")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();

        return HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build()
            .createClient(UserClient.class);
    }
}
```

## 5. 可观测性配置

### 5.1 Micrometer + Prometheus

```java
@Configuration
public class ObservabilityConfig {

    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config()
            .commonTags("application", "platform-user")
            .commonTags("env", System.getProperty("spring.profiles.active", "default"));
    }
}

// 自定义指标
@Component
public class BusinessMetrics {

    private final Counter userRegistrations;
    private final Timer loginTimer;

    public BusinessMetrics(MeterRegistry registry) {
        this.userRegistrations = Counter.builder("business.user.registrations")
            .description("用户注册总数")
            .register(registry);

        this.loginTimer = Timer.builder("business.user.login.time")
            .description("用户登录耗时")
            .register(registry);
    }

    public void recordRegistration() {
        userRegistrations.increment();
    }

    public void recordLoginTime(Runnable action) {
        loginTimer.record(action);
    }
}
```

### 5.2 分布式追踪

```yaml
# application.yml
management:
  tracing:
    sampling:
      probability: 1.0  # 采样率 100%

  otlp:
    tracing:
      endpoint: http://otel-collector:4318/v1/traces
```

---

**文档版本**: 1.0.0
**最后更新**: 2026-01-06
