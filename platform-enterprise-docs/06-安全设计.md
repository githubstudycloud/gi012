# Platform Enterprise - 安全设计

> 认证授权与安全防护体系

## 1. 安全架构总览

### 1.1 零信任安全模型

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Zero Trust Architecture                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌───────────┐    ┌───────────┐    ┌───────────┐    ┌───────────┐      │
│  │  Identity │    │  Device   │    │  Network  │    │   Data    │      │
│  │ Verification│   │  Trust    │    │  Segment  │    │ Protection│      │
│  └─────┬─────┘    └─────┬─────┘    └─────┬─────┘    └─────┬─────┘      │
│        │                │                │                │             │
│        └────────────────┴────────────────┴────────────────┘             │
│                                  │                                       │
│                         ┌────────▼────────┐                             │
│                         │  Policy Engine  │                             │
│                         │  (每次访问验证)  │                             │
│                         └────────┬────────┘                             │
│                                  │                                       │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     Continuous Monitoring                        │   │
│  │               (持续监控、异常检测、自动响应)                      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 安全分层

| 层级 | 组件 | 安全措施 |
|------|------|---------|
| 网络层 | WAF, 防火墙 | DDoS 防护、IP 黑白名单 |
| 传输层 | TLS 1.3 | 全链路加密、证书管理 |
| 网关层 | API Gateway | 认证、限流、防重放 |
| 应用层 | Spring Security | 授权、会话管理、CSRF |
| 数据层 | 数据库 | 加密存储、访问控制 |

## 2. 认证体系

### 2.1 JWT + OAuth2 认证流程

```
┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│  Client  │     │ Gateway  │     │  Auth    │     │ Resource │
│          │     │          │     │  Server  │     │  Server  │
└────┬─────┘     └────┬─────┘     └────┬─────┘     └────┬─────┘
     │                │                │                │
     │  1. Login      │                │                │
     │───────────────>│                │                │
     │                │  2. Forward    │                │
     │                │───────────────>│                │
     │                │                │                │
     │                │  3. Validate & │                │
     │                │     Issue JWT  │                │
     │                │<───────────────│                │
     │  4. JWT Token  │                │                │
     │<───────────────│                │                │
     │                │                │                │
     │  5. API Call   │                │                │
     │  + JWT Token   │                │                │
     │───────────────>│                │                │
     │                │  6. Validate   │                │
     │                │     Token      │                │
     │                │───────────────>│                │
     │                │  7. Token OK   │                │
     │                │<───────────────│                │
     │                │                │                │
     │                │  8. Forward    │                │
     │                │────────────────────────────────>│
     │                │                │                │
     │                │  9. Response   │                │
     │                │<────────────────────────────────│
     │  10. Response  │                │                │
     │<───────────────│                │                │
```

### 2.2 Spring Security 7 配置

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtTokenProvider jwtTokenProvider;
    private final CustomUserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 禁用 CSRF (使用 JWT 无状态)
            .csrf(csrf -> csrf.disable())

            // 禁用 Session
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

            // 授权规则
            .authorizeHttpRequests(auth -> auth
                // 公开端点
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()

                // Swagger 文档
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()

                // 管理接口需要管理员角色
                .requestMatchers("/api/admin/**").hasRole("ADMIN")

                // 其他需要认证
                .anyRequest().authenticated()
            )

            // JWT 过滤器
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)

            // 异常处理
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler())
            );

        return http.build();
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter(jwtTokenProvider, userDetailsService);
    }

    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, authException) -> {
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write(
                """
                {"code": 401, "message": "未授权访问"}
                """
            );
        };
    }

    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, accessDeniedException) -> {
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write(
                """
                {"code": 403, "message": "权限不足"}
                """
            );
        };
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
            throws Exception {
        return config.getAuthenticationManager();
    }
}
```

### 2.3 JWT 过滤器

```java
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final UserDetailsService userDetailsService;

    private static final List<String> EXCLUDE_URLS = List.of(
        "/api/auth/login",
        "/api/auth/register",
        "/api/auth/refresh"
    );

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        // 排除不需要认证的路径
        String path = request.getRequestURI();
        if (EXCLUDE_URLS.stream().anyMatch(path::startsWith)) {
            filterChain.doFilter(request, response);
            return;
        }

        try {
            String token = extractToken(request);

            if (token != null && jwtTokenProvider.validateToken(token)) {
                // 检查令牌是否在黑名单
                if (jwtTokenProvider.isTokenBlacklisted(token)) {
                    throw new InvalidTokenException("令牌已失效");
                }

                String username = jwtTokenProvider.getUsername(token);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("JWT 认证失败", e);
        }

        filterChain.doFilter(request, response);
    }

    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 2.4 令牌刷新机制

```java
@Service
public class TokenService {

    private final JwtTokenProvider jwtTokenProvider;
    private final StringRedisTemplate redisTemplate;

    private static final String REFRESH_TOKEN_PREFIX = "platform:auth:refresh:";
    private static final Duration REFRESH_TOKEN_TTL = Duration.ofDays(7);

    public TokenPair generateTokenPair(User user) {
        // 生成访问令牌 (短期)
        String accessToken = jwtTokenProvider.generateAccessToken(user);

        // 生成刷新令牌 (长期)
        String refreshToken = UUID.randomUUID().toString();

        // 存储刷新令牌
        String key = REFRESH_TOKEN_PREFIX + refreshToken;
        redisTemplate.opsForValue().set(key, user.getId().toString(), REFRESH_TOKEN_TTL);

        return new TokenPair(accessToken, refreshToken, 7200L);
    }

    public TokenPair refreshToken(String refreshToken) {
        String key = REFRESH_TOKEN_PREFIX + refreshToken;
        String userId = redisTemplate.opsForValue().get(key);

        if (userId == null) {
            throw new InvalidTokenException("刷新令牌无效或已过期");
        }

        // 删除旧刷新令牌
        redisTemplate.delete(key);

        // 获取用户信息
        User user = userRepository.findById(Long.parseLong(userId))
            .orElseThrow(() -> new UserNotFoundException("用户不存在"));

        // 生成新令牌对
        return generateTokenPair(user);
    }

    public void revokeToken(String accessToken) {
        // 将访问令牌加入黑名单
        long expiration = jwtTokenProvider.getExpiration(accessToken);
        if (expiration > 0) {
            String key = "platform:auth:blacklist:" + accessToken;
            redisTemplate.opsForValue().set(key, "1", Duration.ofMillis(expiration));
        }
    }
}
```

## 3. 授权体系

### 3.1 RBAC 权限模型

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         RBAC 权限模型                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────┐         ┌──────────┐         ┌──────────┐                │
│  │   User   │   N:N   │   Role   │   N:N   │Permission│                │
│  │  用户    │─────────│   角色   │─────────│   权限   │                │
│  └──────────┘         └──────────┘         └──────────┘                │
│                                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Permission Types:                                               │   │
│  │  ├── MENU      菜单权限 (前端路由)                               │   │
│  │  ├── BUTTON    按钮权限 (前端操作)                               │   │
│  │  └── API       接口权限 (后端接口)                               │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 方法级权限控制

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    @GetMapping
    @PreAuthorize("hasAuthority('user:list')")
    public PageResponse<UserDTO> list(UserQueryRequest request) {
        return userService.list(request);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('user:view') or @permissionChecker.isOwner(#id)")
    public UserDTO getById(@PathVariable Long id) {
        return userService.getById(id);
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN') and hasAuthority('user:create')")
    public UserDTO create(@Valid @RequestBody CreateUserRequest request) {
        return userService.create(request);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('user:update')")
    public UserDTO update(@PathVariable Long id, @Valid @RequestBody UpdateUserRequest request) {
        return userService.update(id, request);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') and hasAuthority('user:delete')")
    public void delete(@PathVariable Long id) {
        userService.delete(id);
    }
}

// 自定义权限检查器
@Component("permissionChecker")
public class PermissionChecker {

    public boolean isOwner(Long resourceId) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null) {
            return false;
        }
        Long currentUserId = ((CustomUserDetails) authentication.getPrincipal()).getId();
        return currentUserId.equals(resourceId);
    }

    public boolean hasPermission(String permission) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication.getAuthorities().stream()
            .anyMatch(auth -> auth.getAuthority().equals(permission));
    }
}
```

### 3.3 数据权限

```java
// 数据权限注解
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataScope {
    String deptAlias() default "dept";
    String userAlias() default "user";
}

// 数据权限切面
@Aspect
@Component
public class DataScopeAspect {

    @Before("@annotation(dataScope)")
    public void dataScopeFilter(JoinPoint joinPoint, DataScope dataScope) {
        CustomUserDetails user = (CustomUserDetails) SecurityContextHolder.getContext()
            .getAuthentication().getPrincipal();

        StringBuilder sqlString = new StringBuilder();
        DataScopeType scopeType = user.getDataScopeType();

        switch (scopeType) {
            case ALL:
                // 全部数据权限，不添加过滤条件
                break;

            case DEPT:
                // 本部门数据
                sqlString.append(String.format(
                    " AND %s.dept_id = %d",
                    dataScope.deptAlias(),
                    user.getDeptId()
                ));
                break;

            case DEPT_AND_CHILD:
                // 本部门及下级部门
                sqlString.append(String.format(
                    " AND %s.dept_id IN (SELECT id FROM t_dept WHERE id = %d OR parent_id = %d)",
                    dataScope.deptAlias(),
                    user.getDeptId(),
                    user.getDeptId()
                ));
                break;

            case SELF:
                // 仅本人数据
                sqlString.append(String.format(
                    " AND %s.id = %d",
                    dataScope.userAlias(),
                    user.getId()
                ));
                break;
        }

        // 设置到线程上下文
        DataScopeContext.set(sqlString.toString());
    }
}
```

## 4. 安全防护

### 4.1 XSS 防护

```java
// XSS 过滤器
@Component
public class XssFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        chain.doFilter(new XssHttpServletRequestWrapper((HttpServletRequest) request), response);
    }
}

// XSS 请求包装器
public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {

    private static final PolicyFactory POLICY = Sanitizers.FORMATTING
        .and(Sanitizers.LINKS)
        .and(Sanitizers.BLOCKS)
        .and(Sanitizers.TABLES);

    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
    }

    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return sanitize(value);
    }

    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values == null) {
            return null;
        }
        return Arrays.stream(values)
            .map(this::sanitize)
            .toArray(String[]::new);
    }

    private String sanitize(String value) {
        if (value == null) {
            return null;
        }
        return POLICY.sanitize(value);
    }
}
```

### 4.2 SQL 注入防护

```java
// 1. 使用参数化查询 (JPA)
@Query("SELECT u FROM User u WHERE u.username = :username")
Optional<User> findByUsername(@Param("username") String username);

// 2. 使用 Criteria API
public List<User> findByConditions(UserSearchCriteria criteria) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> query = cb.createQuery(User.class);
    Root<User> root = query.from(User.class);

    List<Predicate> predicates = new ArrayList<>();

    if (criteria.getUsername() != null) {
        predicates.add(cb.like(root.get("username"),
            "%" + escapeWildcards(criteria.getUsername()) + "%"));
    }

    query.where(predicates.toArray(new Predicate[0]));
    return entityManager.createQuery(query).getResultList();
}

private String escapeWildcards(String value) {
    return value.replace("%", "\\%").replace("_", "\\_");
}
```

### 4.3 CSRF 防护 (适用于传统 Web 应用)

```java
// 对于需要 CSRF 保护的场景
@Configuration
public class CsrfConfig {

    @Bean
    public SecurityFilterChain csrfFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .csrfTokenRequestHandler(new SpaCsrfTokenRequestHandler())
            );
        return http.build();
    }
}
```

### 4.4 防重放攻击

```java
@Component
public class ReplayAttackFilter extends OncePerRequestFilter {

    private final StringRedisTemplate redisTemplate;
    private static final String NONCE_PREFIX = "platform:nonce:";
    private static final Duration NONCE_TTL = Duration.ofMinutes(5);

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String nonce = request.getHeader("X-Request-Nonce");
        String timestamp = request.getHeader("X-Request-Timestamp");

        if (nonce == null || timestamp == null) {
            filterChain.doFilter(request, response);
            return;
        }

        // 检查时间戳是否在有效范围内 (5分钟)
        long requestTime = Long.parseLong(timestamp);
        long currentTime = System.currentTimeMillis();
        if (Math.abs(currentTime - requestTime) > 300000) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "请求已过期");
            return;
        }

        // 检查 nonce 是否已使用
        String key = NONCE_PREFIX + nonce;
        Boolean isNew = redisTemplate.opsForValue().setIfAbsent(key, "1", NONCE_TTL);
        if (Boolean.FALSE.equals(isNew)) {
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "重复请求");
            return;
        }

        filterChain.doFilter(request, response);
    }
}
```

### 4.5 敏感数据加密

```java
// 数据加密服务
@Service
public class EncryptionService {

    @Value("${encryption.key}")
    private String encryptionKey;

    private SecretKey secretKey;

    @PostConstruct
    public void init() {
        byte[] keyBytes = Base64.getDecoder().decode(encryptionKey);
        secretKey = new SecretKeySpec(keyBytes, "AES");
    }

    public String encrypt(String plainText) {
        try {
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            byte[] iv = new byte[12];
            SecureRandom.getInstanceStrong().nextBytes(iv);
            GCMParameterSpec spec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, spec);

            byte[] cipherText = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
            byte[] result = new byte[iv.length + cipherText.length];
            System.arraycopy(iv, 0, result, 0, iv.length);
            System.arraycopy(cipherText, 0, result, iv.length, cipherText.length);

            return Base64.getEncoder().encodeToString(result);
        } catch (Exception e) {
            throw new EncryptionException("加密失败", e);
        }
    }

    public String decrypt(String cipherText) {
        try {
            byte[] decoded = Base64.getDecoder().decode(cipherText);
            byte[] iv = Arrays.copyOfRange(decoded, 0, 12);
            byte[] encrypted = Arrays.copyOfRange(decoded, 12, decoded.length);

            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec spec = new GCMParameterSpec(128, iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec);

            byte[] plainText = cipher.doFinal(encrypted);
            return new String(plainText, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new EncryptionException("解密失败", e);
        }
    }
}

// JPA 属性转换器
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, String> {

    private final EncryptionService encryptionService;

    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) {
            return null;
        }
        return encryptionService.encrypt(attribute);
    }

    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        return encryptionService.decrypt(dbData);
    }
}

// 使用加密字段
@Entity
public class User {
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "id_card")
    private String idCard;  // 身份证号加密存储
}
```

## 5. 安全审计

### 5.1 审计日志

```java
// 审计注解
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface AuditLog {
    String module();
    String operation();
}

// 审计切面
@Aspect
@Component
public class AuditLogAspect {

    private final OperationLogRepository logRepository;

    @Around("@annotation(auditLog)")
    public Object audit(ProceedingJoinPoint joinPoint, AuditLog auditLog) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes)
            RequestContextHolder.getRequestAttributes()).getRequest();

        OperationLog log = new OperationLog();
        log.setModule(auditLog.module());
        log.setOperation(auditLog.operation());
        log.setMethod(joinPoint.getSignature().toString());
        log.setRequestUrl(request.getRequestURI());
        log.setRequestMethod(request.getMethod());
        log.setRequestParams(getRequestParams(joinPoint));
        log.setIpAddress(getClientIp(request));
        log.setUserAgent(request.getHeader("User-Agent"));

        // 获取当前用户
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth != null && auth.getPrincipal() instanceof CustomUserDetails user) {
            log.setUserId(user.getId());
            log.setUsername(user.getUsername());
        }

        long startTime = System.currentTimeMillis();
        try {
            Object result = joinPoint.proceed();
            log.setStatus(1);
            log.setResponseResult(truncate(toJson(result), 2000));
            return result;
        } catch (Exception e) {
            log.setStatus(0);
            log.setErrorMsg(e.getMessage());
            throw e;
        } finally {
            log.setDuration((int) (System.currentTimeMillis() - startTime));
            logRepository.save(log);
        }
    }
}

// 使用审计
@RestController
public class UserController {

    @PostMapping
    @AuditLog(module = "用户管理", operation = "创建用户")
    public UserDTO create(@RequestBody CreateUserRequest request) {
        return userService.create(request);
    }

    @DeleteMapping("/{id}")
    @AuditLog(module = "用户管理", operation = "删除用户")
    public void delete(@PathVariable Long id) {
        userService.delete(id);
    }
}
```

### 5.2 安全事件监控

```java
// 安全事件类型
public enum SecurityEventType {
    LOGIN_SUCCESS,
    LOGIN_FAILURE,
    LOGOUT,
    PASSWORD_CHANGE,
    PERMISSION_DENIED,
    SUSPICIOUS_ACTIVITY
}

// 安全事件发布
@Service
public class SecurityEventPublisher {

    private final ApplicationEventPublisher eventPublisher;
    private final SecurityEventRepository eventRepository;

    public void publishLoginSuccess(Long userId, String ip) {
        SecurityEvent event = SecurityEvent.builder()
            .type(SecurityEventType.LOGIN_SUCCESS)
            .userId(userId)
            .ipAddress(ip)
            .timestamp(Instant.now())
            .build();

        eventRepository.save(event);
        eventPublisher.publishEvent(event);
    }

    public void publishLoginFailure(String username, String ip, String reason) {
        SecurityEvent event = SecurityEvent.builder()
            .type(SecurityEventType.LOGIN_FAILURE)
            .username(username)
            .ipAddress(ip)
            .details(reason)
            .timestamp(Instant.now())
            .build();

        eventRepository.save(event);
        eventPublisher.publishEvent(event);

        // 检测暴力破解
        checkBruteForce(ip, username);
    }

    private void checkBruteForce(String ip, String username) {
        // 5 分钟内失败超过 5 次，锁定账户/IP
        long failCount = eventRepository.countRecentFailures(ip, username, Duration.ofMinutes(5));
        if (failCount >= 5) {
            // 触发告警
            publishEvent(SecurityEventType.SUSPICIOUS_ACTIVITY, "疑似暴力破解: " + username);
        }
    }
}
```

## 6. 前端安全

### 6.1 敏感数据处理

```typescript
// 敏感数据脱敏显示
export function maskPhone(phone: string): string {
  if (!phone || phone.length !== 11) return phone
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
}

export function maskIdCard(idCard: string): string {
  if (!idCard || idCard.length < 15) return idCard
  return idCard.replace(/^(.{6}).*(.{4})$/, '$1********$2')
}

export function maskEmail(email: string): string {
  if (!email) return email
  const [name, domain] = email.split('@')
  if (name.length <= 2) return `${name[0]}***@${domain}`
  return `${name.slice(0, 2)}***@${domain}`
}
```

### 6.2 权限指令

```typescript
// directives/permission.ts
import type { Directive, DirectiveBinding } from 'vue'
import { useAuthStore } from '@/stores/modules/auth'

export const permission: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const { value } = binding
    const authStore = useAuthStore()

    if (value && value instanceof Array && value.length > 0) {
      const hasPermission = value.some(permission =>
        authStore.hasPermission(permission)
      )

      if (!hasPermission) {
        el.parentNode?.removeChild(el)
      }
    }
  }
}

// 使用
// <el-button v-permission="['user:create']">新增</el-button>
```

---

**文档版本**: 1.0.0
**最后更新**: 2026-01-06
