# Platform Enterprise - 数据库设计

> 数据建模规范与分库分表策略

## 1. 数据库选型

### 1.1 存储技术矩阵

| 存储类型 | 技术选型 | 版本 | 使用场景 |
|---------|---------|------|---------|
| 关系型数据库 | PostgreSQL | 17.x | 核心业务数据、事务处理 |
| 缓存 | Redis | 8.x | 会话、热点数据、分布式锁 |
| 搜索引擎 | Elasticsearch | 9.x | 全文搜索、日志分析 |
| 文档存储 | MongoDB | 8.x | 日志、配置、非结构化数据 |
| 时序数据库 | TimescaleDB | - | 监控指标、时间序列数据 |

### 1.2 数据库架构

```
                    ┌─────────────────────────────────────┐
                    │           Application Layer          │
                    └─────────────────┬───────────────────┘
                                      │
                    ┌─────────────────▼───────────────────┐
                    │           Connection Pool            │
                    │           (HikariCP)                 │
                    └─────────────────┬───────────────────┘
                                      │
        ┌─────────────────────────────┼─────────────────────────────┐
        │                             │                             │
┌───────▼───────┐           ┌────────▼────────┐           ┌────────▼────────┐
│    Master     │           │    Read Replica  │           │    Read Replica  │
│  (PostgreSQL) │◀──────────│   (PostgreSQL)   │           │   (PostgreSQL)   │
│               │  流复制    │                  │           │                  │
└───────────────┘           └──────────────────┘           └──────────────────┘
        │
        ▼
┌───────────────┐
│    Backup     │
│  (每日备份)   │
└───────────────┘
```

## 2. 数据建模规范

### 2.1 命名规范

```yaml
# 表命名
table:
  prefix: "t_"                    # 表前缀
  style: snake_case               # 蛇形命名
  examples:
    - t_user                      # 用户表
    - t_user_role                 # 用户角色关联表
    - t_sys_config                # 系统配置表

# 字段命名
column:
  style: snake_case
  reserved:
    - id                          # 主键
    - created_at                  # 创建时间
    - created_by                  # 创建人
    - updated_at                  # 更新时间
    - updated_by                  # 更新人
    - deleted                     # 逻辑删除标记
    - version                     # 乐观锁版本

# 索引命名
index:
  primary: "pk_{table}"           # 主键索引
  unique: "uk_{table}_{columns}"  # 唯一索引
  normal: "idx_{table}_{columns}" # 普通索引
  foreign: "fk_{table}_{ref}"     # 外键索引
```

### 2.2 字段类型规范

| 业务类型 | PostgreSQL 类型 | Java 类型 | 说明 |
|---------|----------------|-----------|------|
| 主键 | BIGSERIAL | Long | 自增主键 |
| UUID | UUID | UUID | 全局唯一标识 |
| 短文本 | VARCHAR(n) | String | n ≤ 255 |
| 长文本 | TEXT | String | 大文本 |
| 整数 | INTEGER | Integer | 32位整数 |
| 长整数 | BIGINT | Long | 64位整数 |
| 小数 | DECIMAL(p,s) | BigDecimal | 精确计算 |
| 布尔 | BOOLEAN | Boolean | true/false |
| 日期 | DATE | LocalDate | 仅日期 |
| 时间戳 | TIMESTAMP | LocalDateTime | 日期时间 |
| 时间戳(时区) | TIMESTAMPTZ | Instant | 带时区 |
| 枚举 | VARCHAR(20) | Enum | 存储枚举名 |
| JSON | JSONB | Map/Object | JSON 数据 |
| 数组 | ARRAY | List | 数组类型 |

## 3. 核心表设计

### 3.1 用户模块

```sql
-- 用户表
CREATE TABLE t_user (
    id              BIGSERIAL PRIMARY KEY,
    username        VARCHAR(50) NOT NULL,
    password        VARCHAR(100) NOT NULL,
    email           VARCHAR(100),
    phone           VARCHAR(20),
    nickname        VARCHAR(100),
    avatar          VARCHAR(255),
    gender          SMALLINT DEFAULT 0,          -- 0:未知 1:男 2:女
    status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    last_login_at   TIMESTAMP,
    last_login_ip   VARCHAR(50),
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by      BIGINT,
    updated_at      TIMESTAMP,
    updated_by      BIGINT,
    deleted         BOOLEAN NOT NULL DEFAULT FALSE,
    version         INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT uk_user_username UNIQUE (username),
    CONSTRAINT uk_user_email UNIQUE (email) WHERE email IS NOT NULL
);

CREATE INDEX idx_user_status ON t_user(status) WHERE deleted = FALSE;
CREATE INDEX idx_user_phone ON t_user(phone) WHERE phone IS NOT NULL AND deleted = FALSE;

COMMENT ON TABLE t_user IS '用户表';
COMMENT ON COLUMN t_user.status IS '状态: ACTIVE-正常, INACTIVE-未激活, LOCKED-锁定, DISABLED-禁用';

-- 角色表
CREATE TABLE t_role (
    id              BIGSERIAL PRIMARY KEY,
    code            VARCHAR(50) NOT NULL,
    name            VARCHAR(100) NOT NULL,
    description     VARCHAR(255),
    sort_order      INTEGER DEFAULT 0,
    status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by      BIGINT,
    updated_at      TIMESTAMP,
    updated_by      BIGINT,
    deleted         BOOLEAN NOT NULL DEFAULT FALSE,

    CONSTRAINT uk_role_code UNIQUE (code)
);

COMMENT ON TABLE t_role IS '角色表';

-- 用户角色关联表
CREATE TABLE t_user_role (
    id              BIGSERIAL PRIMARY KEY,
    user_id         BIGINT NOT NULL,
    role_id         BIGINT NOT NULL,
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by      BIGINT,

    CONSTRAINT uk_user_role UNIQUE (user_id, role_id),
    CONSTRAINT fk_user_role_user FOREIGN KEY (user_id) REFERENCES t_user(id),
    CONSTRAINT fk_user_role_role FOREIGN KEY (role_id) REFERENCES t_role(id)
);

CREATE INDEX idx_user_role_user ON t_user_role(user_id);
CREATE INDEX idx_user_role_role ON t_user_role(role_id);

-- 权限表
CREATE TABLE t_permission (
    id              BIGSERIAL PRIMARY KEY,
    parent_id       BIGINT DEFAULT 0,
    code            VARCHAR(100) NOT NULL,
    name            VARCHAR(100) NOT NULL,
    type            VARCHAR(20) NOT NULL,        -- MENU, BUTTON, API
    path            VARCHAR(255),                -- 前端路由
    component       VARCHAR(255),                -- 前端组件
    icon            VARCHAR(100),
    sort_order      INTEGER DEFAULT 0,
    status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP,

    CONSTRAINT uk_permission_code UNIQUE (code)
);

CREATE INDEX idx_permission_parent ON t_permission(parent_id);

-- 角色权限关联表
CREATE TABLE t_role_permission (
    id              BIGSERIAL PRIMARY KEY,
    role_id         BIGINT NOT NULL,
    permission_id   BIGINT NOT NULL,
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uk_role_permission UNIQUE (role_id, permission_id),
    CONSTRAINT fk_role_perm_role FOREIGN KEY (role_id) REFERENCES t_role(id),
    CONSTRAINT fk_role_perm_perm FOREIGN KEY (permission_id) REFERENCES t_permission(id)
);
```

### 3.2 系统模块

```sql
-- 系统配置表
CREATE TABLE t_sys_config (
    id              BIGSERIAL PRIMARY KEY,
    config_key      VARCHAR(100) NOT NULL,
    config_value    TEXT,
    config_type     VARCHAR(20) DEFAULT 'STRING', -- STRING, NUMBER, BOOLEAN, JSON
    description     VARCHAR(255),
    is_system       BOOLEAN DEFAULT FALSE,        -- 系统内置不可删除
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP,

    CONSTRAINT uk_sys_config_key UNIQUE (config_key)
);

-- 字典类型表
CREATE TABLE t_dict_type (
    id              BIGSERIAL PRIMARY KEY,
    code            VARCHAR(50) NOT NULL,
    name            VARCHAR(100) NOT NULL,
    description     VARCHAR(255),
    status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP,

    CONSTRAINT uk_dict_type_code UNIQUE (code)
);

-- 字典数据表
CREATE TABLE t_dict_data (
    id              BIGSERIAL PRIMARY KEY,
    type_id         BIGINT NOT NULL,
    label           VARCHAR(100) NOT NULL,
    value           VARCHAR(100) NOT NULL,
    sort_order      INTEGER DEFAULT 0,
    css_class       VARCHAR(100),                -- 前端样式
    status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    is_default      BOOLEAN DEFAULT FALSE,
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP,

    CONSTRAINT fk_dict_data_type FOREIGN KEY (type_id) REFERENCES t_dict_type(id)
);

CREATE INDEX idx_dict_data_type ON t_dict_data(type_id);

-- 操作日志表
CREATE TABLE t_operation_log (
    id              BIGSERIAL PRIMARY KEY,
    user_id         BIGINT,
    username        VARCHAR(50),
    module          VARCHAR(50),                  -- 模块
    operation       VARCHAR(50),                  -- 操作类型
    method          VARCHAR(200),                 -- 方法名
    request_url     VARCHAR(500),
    request_method  VARCHAR(10),
    request_params  TEXT,
    response_result TEXT,
    ip_address      VARCHAR(50),
    user_agent      VARCHAR(500),
    duration        INTEGER,                      -- 执行时长(ms)
    status          SMALLINT,                     -- 0:失败 1:成功
    error_msg       TEXT,
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_operation_log_user ON t_operation_log(user_id);
CREATE INDEX idx_operation_log_created ON t_operation_log(created_at);

-- 按月分区 (PostgreSQL 原生分区)
-- CREATE TABLE t_operation_log (...)
-- PARTITION BY RANGE (created_at);
--
-- CREATE TABLE t_operation_log_2026_01
--     PARTITION OF t_operation_log
--     FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');
```

### 3.3 文件模块

```sql
-- 文件信息表
CREATE TABLE t_file (
    id              BIGSERIAL PRIMARY KEY,
    file_key        VARCHAR(100) NOT NULL,       -- 文件唯一标识
    original_name   VARCHAR(255) NOT NULL,       -- 原始文件名
    storage_name    VARCHAR(255) NOT NULL,       -- 存储文件名
    storage_path    VARCHAR(500) NOT NULL,       -- 存储路径
    storage_type    VARCHAR(20) NOT NULL,        -- LOCAL, S3, OSS
    content_type    VARCHAR(100),                -- MIME 类型
    file_size       BIGINT NOT NULL,             -- 文件大小(字节)
    file_hash       VARCHAR(64),                 -- MD5/SHA256
    thumbnail_path  VARCHAR(500),                -- 缩略图路径
    upload_user_id  BIGINT,
    download_count  INTEGER DEFAULT 0,
    status          VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT uk_file_key UNIQUE (file_key)
);

CREATE INDEX idx_file_user ON t_file(upload_user_id);
CREATE INDEX idx_file_hash ON t_file(file_hash);
```

## 4. 索引设计

### 4.1 索引策略

```sql
-- 1. B-Tree 索引 (默认，适用于等值和范围查询)
CREATE INDEX idx_user_created ON t_user(created_at);

-- 2. 部分索引 (减少索引大小)
CREATE INDEX idx_user_active ON t_user(status)
    WHERE deleted = FALSE;

-- 3. 复合索引 (遵循最左前缀原则)
CREATE INDEX idx_log_user_time ON t_operation_log(user_id, created_at DESC);

-- 4. 覆盖索引 (包含查询所需所有字段)
CREATE INDEX idx_user_login ON t_user(username)
    INCLUDE (password, status);

-- 5. GIN 索引 (JSONB 和全文搜索)
CREATE INDEX idx_user_metadata ON t_user USING GIN (metadata);

-- 6. 表达式索引
CREATE INDEX idx_user_lower_email ON t_user(LOWER(email));

-- 7. BRIN 索引 (大表时间序列数据)
CREATE INDEX idx_log_created_brin ON t_operation_log
    USING BRIN (created_at);
```

### 4.2 索引监控

```sql
-- 查看未使用的索引
SELECT
    schemaname,
    relname AS table_name,
    indexrelname AS index_name,
    idx_scan AS times_used,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY pg_relation_size(indexrelid) DESC;

-- 查看缺失的索引建议
SELECT
    relname AS table_name,
    seq_scan,
    seq_tup_read,
    idx_scan,
    seq_tup_read / seq_scan AS avg_seq_tup_read
FROM pg_stat_user_tables
WHERE seq_scan > 0
ORDER BY seq_tup_read DESC
LIMIT 20;
```

## 5. 读写分离

### 5.1 Spring 配置

```yaml
# application.yml
spring:
  datasource:
    master:
      url: jdbc:postgresql://master:5432/platform
      username: ${DB_USERNAME}
      password: ${DB_PASSWORD}
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5

    slaves:
      - url: jdbc:postgresql://slave1:5432/platform
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
        hikari:
          maximum-pool-size: 30
          minimum-idle: 10

      - url: jdbc:postgresql://slave2:5432/platform
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
        hikari:
          maximum-pool-size: 30
          minimum-idle: 10
```

### 5.2 动态数据源

```java
// 数据源路由
public class DynamicDataSource extends AbstractRoutingDataSource {

    private static final ThreadLocal<DataSourceType> CONTEXT = new ThreadLocal<>();

    @Override
    protected Object determineCurrentLookupKey() {
        return CONTEXT.get();
    }

    public static void setDataSourceType(DataSourceType type) {
        CONTEXT.set(type);
    }

    public static void clear() {
        CONTEXT.remove();
    }
}

// 数据源类型
public enum DataSourceType {
    MASTER,
    SLAVE
}

// 切面实现
@Aspect
@Component
public class DataSourceAspect {

    @Around("@annotation(readOnly)")
    public Object around(ProceedingJoinPoint point, ReadOnly readOnly) throws Throwable {
        try {
            DynamicDataSource.setDataSourceType(DataSourceType.SLAVE);
            return point.proceed();
        } finally {
            DynamicDataSource.clear();
        }
    }

    @Around("@annotation(org.springframework.transaction.annotation.Transactional)")
    public Object aroundTransaction(ProceedingJoinPoint point) throws Throwable {
        try {
            DynamicDataSource.setDataSourceType(DataSourceType.MASTER);
            return point.proceed();
        } finally {
            DynamicDataSource.clear();
        }
    }
}

// 只读注解
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ReadOnly {
}

// 使用示例
@Service
public class UserService {

    @ReadOnly
    public User findById(Long id) {
        // 使用从库
        return userRepository.findById(id).orElse(null);
    }

    @Transactional
    public User create(User user) {
        // 使用主库
        return userRepository.save(user);
    }
}
```

## 6. 分库分表 (ShardingSphere)

### 6.1 配置

```yaml
# application-sharding.yml
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: org.postgresql.Driver
        jdbc-url: jdbc:postgresql://db0:5432/platform
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: org.postgresql.Driver
        jdbc-url: jdbc:postgresql://db1:5432/platform
        username: ${DB_USERNAME}
        password: ${DB_PASSWORD}

    rules:
      sharding:
        tables:
          # 订单表分片配置
          t_order:
            actual-data-nodes: ds$->{0..1}.t_order_$->{0..15}
            database-strategy:
              standard:
                sharding-column: user_id
                sharding-algorithm-name: database-inline
            table-strategy:
              standard:
                sharding-column: order_id
                sharding-algorithm-name: table-inline
            key-generate-strategy:
              column: order_id
              key-generator-name: snowflake

        sharding-algorithms:
          database-inline:
            type: INLINE
            props:
              algorithm-expression: ds$->{user_id % 2}
          table-inline:
            type: INLINE
            props:
              algorithm-expression: t_order_$->{order_id % 16}

        key-generators:
          snowflake:
            type: SNOWFLAKE
            props:
              worker-id: 1
```

### 6.2 分片键选择原则

| 场景 | 推荐分片键 | 原因 |
|------|-----------|------|
| 用户数据 | user_id | 按用户查询最频繁 |
| 订单数据 | user_id + order_id | 支持按用户和订单查询 |
| 日志数据 | 时间 | 按时间范围查询 |
| 商品数据 | 不分片 | 数据量小，全局访问 |

## 7. 缓存设计

### 7.1 多级缓存架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        Application                               │
├─────────────────────────────────────────────────────────────────┤
│  L1 Cache (Caffeine)     │  本地缓存，毫秒级响应，容量有限      │
├─────────────────────────────────────────────────────────────────┤
│  L2 Cache (Redis)        │  分布式缓存，毫秒级响应，容量大      │
├─────────────────────────────────────────────────────────────────┤
│  Database (PostgreSQL)   │  持久化存储，10ms+ 响应              │
└─────────────────────────────────────────────────────────────────┘
```

### 7.2 缓存实现

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        // Caffeine 本地缓存
        CaffeineCacheManager caffeineCacheManager = new CaffeineCacheManager();
        caffeineCacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(5)));

        // Redis 分布式缓存
        RedisCacheManager redisCacheManager = RedisCacheManager.builder(redisConnectionFactory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer())))
            .build();

        // 多级缓存
        return new CompositeCacheManager(caffeineCacheManager, redisCacheManager);
    }
}

// 缓存使用
@Service
public class UserService {

    @Cacheable(value = "user", key = "#id", unless = "#result == null")
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    @CachePut(value = "user", key = "#user.id")
    public User update(User user) {
        return userRepository.save(user);
    }

    @CacheEvict(value = "user", key = "#id")
    public void delete(Long id) {
        userRepository.deleteById(id);
    }

    @CacheEvict(value = "user", allEntries = true)
    public void clearCache() {
        // 清空所有用户缓存
    }
}
```

## 8. 数据备份与恢复

### 8.1 备份策略

```bash
#!/bin/bash
# backup.sh - PostgreSQL 备份脚本

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR=/backup/postgres
RETENTION_DAYS=30

# 全量备份
pg_dump -h localhost -U postgres -F c -b -v -f "${BACKUP_DIR}/platform_${DATE}.dump" platform

# 压缩
gzip "${BACKUP_DIR}/platform_${DATE}.dump"

# 上传到对象存储
aws s3 cp "${BACKUP_DIR}/platform_${DATE}.dump.gz" s3://backup-bucket/postgres/

# 清理旧备份
find ${BACKUP_DIR} -name "*.dump.gz" -mtime +${RETENTION_DAYS} -delete
```

### 8.2 恢复流程

```bash
#!/bin/bash
# restore.sh - PostgreSQL 恢复脚本

BACKUP_FILE=$1

# 下载备份
aws s3 cp "s3://backup-bucket/postgres/${BACKUP_FILE}" /tmp/

# 解压
gunzip "/tmp/${BACKUP_FILE}"

# 恢复
pg_restore -h localhost -U postgres -d platform -v "/tmp/${BACKUP_FILE%.gz}"
```

---

**文档版本**: 1.0.0
**最后更新**: 2026-01-06
