# Platform Enterprise - 微服务设计

> 微服务拆分策略与服务间通信机制

## 1. 服务拆分原则

### 1.1 拆分策略

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         服务拆分决策树                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│    业务边界清晰?  ─── No ──→  暂不拆分，保持单体                        │
│         │                                                                │
│        Yes                                                               │
│         │                                                                │
│         ▼                                                                │
│    团队独立维护?  ─── No ──→  合并到相关服务                            │
│         │                                                                │
│        Yes                                                               │
│         │                                                                │
│         ▼                                                                │
│    独立部署需求?  ─── No ──→  作为模块，不独立部署                      │
│         │                                                                │
│        Yes                                                               │
│         │                                                                │
│         ▼                                                                │
│    独立扩展需求?  ─── No ──→  考虑合并                                  │
│         │                                                                │
│        Yes                                                               │
│         │                                                                │
│         ▼                                                                │
│      拆分为独立微服务                                                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 服务边界定义

| 服务 | 领域 | 职责边界 | 数据边界 |
|------|------|---------|---------|
| platform-auth | 认证 | 登录、登出、令牌管理 | 令牌、会话 |
| platform-user | 用户 | 用户CRUD、角色权限 | 用户、角色、权限 |
| platform-business | 业务 | 核心业务逻辑 | 业务数据 |
| platform-file | 文件 | 文件上传、下载、存储 | 文件元数据 |
| platform-message | 消息 | 站内信、推送、短信 | 消息记录 |
| platform-job | 任务 | 定时任务调度执行 | 任务配置、日志 |
| platform-monitor | 监控 | 服务监控、告警 | 监控指标、告警规则 |

## 2. 服务注册与发现

### 2.1 使用 Consul 作为服务注册中心

```yaml
# application.yml
spring:
  cloud:
    consul:
      host: ${CONSUL_HOST:localhost}
      port: ${CONSUL_PORT:8500}
      discovery:
        service-name: ${spring.application.name}
        instance-id: ${spring.application.name}:${server.port}
        health-check-path: /actuator/health
        health-check-interval: 10s
        prefer-ip-address: true
        tags:
          - version=${app.version}
          - env=${spring.profiles.active}
```

### 2.2 服务发现配置

```java
@Configuration
public class DiscoveryConfig {

    @Bean
    @LoadBalanced
    public RestClient.Builder restClientBuilder() {
        return RestClient.builder();
    }

    @Bean
    public DiscoveryClient.Filter healthyInstanceFilter() {
        return instances -> instances.stream()
            .filter(instance -> "passing".equals(instance.getHealthStatus()))
            .toList();
    }
}
```

## 3. 服务间通信

### 3.1 同步通信 - 声明式 HTTP 客户端

```java
// 用户服务客户端定义
@HttpExchange
public interface UserServiceClient {

    @GetExchange("/users/{id}")
    UserDTO getUser(@PathVariable Long id);

    @GetExchange("/users/batch")
    List<UserDTO> getUsersByIds(@RequestParam List<Long> ids);

    @PostExchange("/users/validate")
    boolean validateUser(@RequestBody ValidateRequest request);
}

// 客户端配置
@Configuration
public class ServiceClientConfig {

    @Bean
    public UserServiceClient userServiceClient(
            RestClient.Builder builder,
            @Value("${services.user.url}") String baseUrl) {

        RestClient restClient = builder
            .baseUrl(baseUrl)
            .defaultHeader("X-Internal-Call", "true")
            .requestInterceptor(new TracingInterceptor())
            .build();

        HttpServiceProxyFactory factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build();

        return factory.createClient(UserServiceClient.class);
    }
}

// 重试配置
@Configuration
public class RetryConfig {

    @Bean
    public RetryTemplate retryTemplate() {
        return RetryTemplate.builder()
            .maxAttempts(3)
            .exponentialBackoff(1000, 2, 10000)
            .retryOn(ServiceUnavailableException.class)
            .build();
    }
}
```

### 3.2 异步通信 - RabbitMQ

```java
// 消息队列配置
@Configuration
public class RabbitMQConfig {

    public static final String EXCHANGE_USER = "platform.topic.user";
    public static final String QUEUE_USER_CREATED = "platform.user.created";
    public static final String ROUTING_KEY_USER_CREATED = "user.created";

    @Bean
    public TopicExchange userExchange() {
        return new TopicExchange(EXCHANGE_USER, true, false);
    }

    @Bean
    public Queue userCreatedQueue() {
        return QueueBuilder.durable(QUEUE_USER_CREATED)
            .withArgument("x-dead-letter-exchange", "platform.dlx")
            .withArgument("x-dead-letter-routing-key", "user.created.dlq")
            .build();
    }

    @Bean
    public Binding userCreatedBinding() {
        return BindingBuilder.bind(userCreatedQueue())
            .to(userExchange())
            .with(ROUTING_KEY_USER_CREATED);
    }
}

// 消息发布
@Service
public class UserEventPublisher {

    private final RabbitTemplate rabbitTemplate;
    private final ObjectMapper objectMapper;

    public void publishUserCreated(User user) {
        UserCreatedEvent event = new UserCreatedEvent(
            user.getId(),
            user.getUsername(),
            user.getEmail(),
            Instant.now()
        );

        rabbitTemplate.convertAndSend(
            RabbitMQConfig.EXCHANGE_USER,
            RabbitMQConfig.ROUTING_KEY_USER_CREATED,
            event
        );
    }
}

// 消息消费
@Component
public class UserEventConsumer {

    private static final Logger log = LoggerFactory.getLogger(UserEventConsumer.class);

    private final NotificationService notificationService;

    @RabbitListener(queues = RabbitMQConfig.QUEUE_USER_CREATED)
    public void handleUserCreated(UserCreatedEvent event) {
        log.info("Received user created event: {}", event.userId());

        // 发送欢迎邮件
        notificationService.sendWelcomeEmail(event.userId(), event.email());
    }
}

// 事件定义
public record UserCreatedEvent(
    Long userId,
    String username,
    String email,
    Instant timestamp
) implements Serializable {}
```

### 3.3 事件驱动架构

```java
// 领域事件基类
public abstract class DomainEvent {
    private final String eventId = UUID.randomUUID().toString();
    private final Instant occurredAt = Instant.now();
    private final String aggregateType;
    private final String aggregateId;

    protected DomainEvent(String aggregateType, String aggregateId) {
        this.aggregateType = aggregateType;
        this.aggregateId = aggregateId;
    }
}

// 事件发布器
@Component
public class DomainEventPublisher {

    private final ApplicationEventPublisher localPublisher;
    private final RabbitTemplate rabbitTemplate;

    @Transactional
    public void publish(DomainEvent event) {
        // 1. 本地事件 (同一服务内)
        localPublisher.publishEvent(event);

        // 2. 持久化到 Outbox 表 (保证最终一致性)
        saveToOutbox(event);
    }

    private void saveToOutbox(DomainEvent event) {
        // 保存到 outbox 表，由定时任务发送到消息队列
    }
}

// Outbox 模式实现
@Entity
@Table(name = "t_outbox")
public class OutboxMessage {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String eventType;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String payload;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private OutboxStatus status = OutboxStatus.PENDING;

    @Column(nullable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    private LocalDateTime processedAt;

    private int retryCount = 0;
}

// Outbox 消息发送任务
@Component
public class OutboxProcessor {

    private final OutboxRepository outboxRepository;
    private final RabbitTemplate rabbitTemplate;

    @Scheduled(fixedDelay = 1000)
    @Transactional
    public void processOutbox() {
        List<OutboxMessage> messages = outboxRepository
            .findByStatusAndRetryCountLessThan(OutboxStatus.PENDING, 3);

        for (OutboxMessage message : messages) {
            try {
                rabbitTemplate.convertAndSend(
                    "platform.events",
                    message.getEventType(),
                    message.getPayload()
                );
                message.setStatus(OutboxStatus.PROCESSED);
                message.setProcessedAt(LocalDateTime.now());
            } catch (Exception e) {
                message.setRetryCount(message.getRetryCount() + 1);
                if (message.getRetryCount() >= 3) {
                    message.setStatus(OutboxStatus.FAILED);
                }
            }
            outboxRepository.save(message);
        }
    }
}
```

## 4. 服务治理

### 4.1 熔断器 (Circuit Breaker)

```java
// Resilience4j 熔断配置
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public CircuitBreakerRegistry circuitBreakerRegistry() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)                    // 失败率阈值
            .waitDurationInOpenState(Duration.ofSeconds(30))  // 熔断时间
            .slidingWindowSize(10)                       // 滑动窗口大小
            .minimumNumberOfCalls(5)                     // 最小调用次数
            .permittedNumberOfCallsInHalfOpenState(3)   // 半开状态允许调用次数
            .build();

        return CircuitBreakerRegistry.of(config);
    }
}

// 使用熔断器
@Service
public class UserServiceAdapter {

    private final UserServiceClient userServiceClient;
    private final CircuitBreaker circuitBreaker;

    public UserServiceAdapter(
            UserServiceClient userServiceClient,
            CircuitBreakerRegistry registry) {
        this.userServiceClient = userServiceClient;
        this.circuitBreaker = registry.circuitBreaker("userService");
    }

    public UserDTO getUser(Long id) {
        return circuitBreaker.executeSupplier(() -> userServiceClient.getUser(id));
    }

    public UserDTO getUserWithFallback(Long id) {
        return Try.ofSupplier(CircuitBreaker.decorateSupplier(
                circuitBreaker,
                () -> userServiceClient.getUser(id)))
            .recover(CallNotPermittedException.class, e -> getCachedUser(id))
            .get();
    }

    private UserDTO getCachedUser(Long id) {
        // 从缓存获取降级数据
        return new UserDTO(id, "Unknown", null);
    }
}
```

### 4.2 限流 (Rate Limiting)

```java
@Configuration
public class RateLimiterConfig {

    @Bean
    public RateLimiterRegistry rateLimiterRegistry() {
        RateLimiterConfig config = RateLimiterConfig.custom()
            .limitForPeriod(100)                         // 每周期允许的请求数
            .limitRefreshPeriod(Duration.ofSeconds(1))  // 刷新周期
            .timeoutDuration(Duration.ofMillis(500))    // 等待超时
            .build();

        return RateLimiterRegistry.of(config);
    }
}

// 使用限流
@RestController
@RequestMapping("/api")
public class ApiController {

    private final RateLimiter rateLimiter;

    @GetMapping("/resource")
    public ApiResponse<String> getResource() {
        return rateLimiter.executeSupplier(() -> {
            // 业务逻辑
            return ApiResponse.success("data");
        });
    }
}

// 基于 Redis 的分布式限流
@Component
public class RedisRateLimiter {

    private final StringRedisTemplate redisTemplate;

    private static final String SCRIPT = """
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])
        local current = redis.call('INCR', key)
        if current == 1 then
            redis.call('EXPIRE', key, window)
        end
        if current > limit then
            return 0
        end
        return 1
        """;

    public boolean tryAcquire(String key, int limit, int windowSeconds) {
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(SCRIPT, Long.class),
            List.of("rate_limit:" + key),
            String.valueOf(limit),
            String.valueOf(windowSeconds)
        );
        return result != null && result == 1;
    }
}
```

### 4.3 超时控制

```yaml
# application.yml
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 5000
        response-timeout: 30s

# 服务级别超时
services:
  user:
    connect-timeout: 3000
    read-timeout: 10000
  business:
    connect-timeout: 3000
    read-timeout: 30000
```

## 5. 配置中心

### 5.1 使用 Consul KV 作为配置中心

```yaml
# bootstrap.yml
spring:
  cloud:
    consul:
      config:
        enabled: true
        format: YAML
        prefix: config
        default-context: platform
        profile-separator: '::'
        data-key: data
        watch:
          enabled: true
          delay: 1000
```

### 5.2 配置结构

```
consul/
└── config/
    ├── platform/              # 公共配置
    │   └── data
    ├── platform-gateway/      # 网关配置
    │   └── data
    ├── platform-auth/         # 认证服务配置
    │   └── data
    └── platform-user/         # 用户服务配置
        └── data
```

### 5.3 配置刷新

```java
@RestController
@RefreshScope
public class ConfigController {

    @Value("${app.feature.enabled:false}")
    private boolean featureEnabled;

    @GetMapping("/config/feature")
    public boolean isFeatureEnabled() {
        return featureEnabled;
    }
}
```

## 6. 分布式事务

### 6.1 Saga 模式

```java
// Saga 编排器
@Component
public class OrderSaga {

    private final UserServiceClient userServiceClient;
    private final InventoryServiceClient inventoryServiceClient;
    private final PaymentServiceClient paymentServiceClient;
    private final OrderRepository orderRepository;

    @Transactional
    public OrderResult createOrder(CreateOrderRequest request) {
        // 1. 创建订单 (本地事务)
        Order order = Order.create(request);
        order.setStatus(OrderStatus.PENDING);
        orderRepository.save(order);

        try {
            // 2. 扣减库存
            inventoryServiceClient.reserve(order.getItems());

            try {
                // 3. 扣款
                paymentServiceClient.charge(order.getUserId(), order.getTotalAmount());

                // 成功
                order.setStatus(OrderStatus.COMPLETED);
                orderRepository.save(order);

                return OrderResult.success(order);

            } catch (Exception e) {
                // 扣款失败，补偿库存
                inventoryServiceClient.release(order.getItems());
                throw e;
            }

        } catch (Exception e) {
            // 失败，取消订单
            order.setStatus(OrderStatus.CANCELLED);
            orderRepository.save(order);

            return OrderResult.failure(order, e.getMessage());
        }
    }
}

// 使用状态机实现 Saga
@Configuration
@EnableStateMachineFactory
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderState, OrderEvent> {

    @Override
    public void configure(StateMachineStateConfigurer<OrderState, OrderEvent> states) throws Exception {
        states
            .withStates()
            .initial(OrderState.PENDING)
            .state(OrderState.INVENTORY_RESERVED)
            .state(OrderState.PAYMENT_COMPLETED)
            .end(OrderState.COMPLETED)
            .end(OrderState.CANCELLED);
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<OrderState, OrderEvent> transitions) throws Exception {
        transitions
            .withExternal()
                .source(OrderState.PENDING)
                .target(OrderState.INVENTORY_RESERVED)
                .event(OrderEvent.RESERVE_INVENTORY)
                .action(reserveInventoryAction())
            .and()
            .withExternal()
                .source(OrderState.INVENTORY_RESERVED)
                .target(OrderState.PAYMENT_COMPLETED)
                .event(OrderEvent.PROCESS_PAYMENT)
                .action(processPaymentAction())
            .and()
            .withExternal()
                .source(OrderState.PAYMENT_COMPLETED)
                .target(OrderState.COMPLETED)
                .event(OrderEvent.COMPLETE_ORDER);
    }
}
```

### 6.2 TCC 模式

```java
// TCC 接口定义
public interface TccService<T> {
    // Try: 资源预留
    boolean tryAction(T context);

    // Confirm: 确认提交
    boolean confirm(T context);

    // Cancel: 取消回滚
    boolean cancel(T context);
}

// 库存 TCC 实现
@Service
public class InventoryTccService implements TccService<InventoryContext> {

    private final InventoryRepository inventoryRepository;
    private final FrozenInventoryRepository frozenRepository;

    @Override
    @Transactional
    public boolean tryAction(InventoryContext context) {
        // 检查库存
        Inventory inventory = inventoryRepository.findByProductId(context.getProductId());
        if (inventory.getAvailable() < context.getQuantity()) {
            return false;
        }

        // 冻结库存
        inventory.freeze(context.getQuantity());
        inventoryRepository.save(inventory);

        // 记录冻结
        FrozenInventory frozen = new FrozenInventory(
            context.getTransactionId(),
            context.getProductId(),
            context.getQuantity()
        );
        frozenRepository.save(frozen);

        return true;
    }

    @Override
    @Transactional
    public boolean confirm(InventoryContext context) {
        // 扣减冻结库存
        FrozenInventory frozen = frozenRepository
            .findByTransactionId(context.getTransactionId());

        Inventory inventory = inventoryRepository.findByProductId(context.getProductId());
        inventory.confirmFreeze(frozen.getQuantity());
        inventoryRepository.save(inventory);

        frozenRepository.delete(frozen);
        return true;
    }

    @Override
    @Transactional
    public boolean cancel(InventoryContext context) {
        // 释放冻结库存
        FrozenInventory frozen = frozenRepository
            .findByTransactionId(context.getTransactionId());

        if (frozen != null) {
            Inventory inventory = inventoryRepository.findByProductId(context.getProductId());
            inventory.releaseFreeze(frozen.getQuantity());
            inventoryRepository.save(inventory);

            frozenRepository.delete(frozen);
        }
        return true;
    }
}
```

## 7. 服务网格 (可选)

### 7.1 Istio 集成

```yaml
# platform-user-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: platform-user
  labels:
    app: platform-user
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: platform-user
  template:
    metadata:
      labels:
        app: platform-user
        version: v1
      annotations:
        sidecar.istio.io/inject: "true"
    spec:
      containers:
        - name: platform-user
          image: platform-user:1.0.0
          ports:
            - containerPort: 8082
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: platform-user
spec:
  hosts:
    - platform-user
  http:
    - route:
        - destination:
            host: platform-user
            subset: v1
          weight: 90
        - destination:
            host: platform-user
            subset: v2
          weight: 10
---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: platform-user
spec:
  host: platform-user
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        h2UpgradePolicy: UPGRADE
        http1MaxPendingRequests: 100
        http2MaxRequests: 1000
    outlierDetection:
      consecutive5xxErrors: 5
      interval: 30s
      baseEjectionTime: 30s
  subsets:
    - name: v1
      labels:
        version: v1
    - name: v2
      labels:
        version: v2
```

---

**文档版本**: 1.0.0
**最后更新**: 2026-01-06
